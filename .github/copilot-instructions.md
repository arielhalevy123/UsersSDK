## Repo snapshot & intent

This is a small Spring Boot service (package `com.example.userssdk`) that manages Users, Roles and per-user custom fields. It uses Spring Data JPA (Postgres), Spring Security with JWT, and Lombok-based entities/DTOs.

## Quick start (build / run)

- Build and test locally with Gradle wrapper:
  - `./gradlew build` — compiles and runs unit tests
  - `./gradlew bootRun` — runs the app locally (uses `application.properties`)
- Run the full stack with Docker Compose (recommended for DB):
  - `docker compose up --build` from the project root. This starts Postgres (container name `postgres-container`) and the `app` service.

Environment hints
- DB config is in `src/main/resources/application.properties` (defaults to `jdbc:postgresql://localhost:5432/userdb`). The compose file wires the app to the `postgres` service via `SPRING_DATASOURCE_URL`.
- JWT secret property: `app.jwt.secret` — passed into `JwtUtil` and used to sign tokens.

## Key architectural points (what an AI agent should know)

- Packages:
  - `controllers` — REST endpoints (notably `AuthController` and `AdminController`).
  - `service` — business logic (`UserService` / `UserServiceImpl`).
  - `repositories` — Spring Data JPA interfaces (`UserRepository`, `UserCustomFieldRepository`).
  - `config` — security & JWT (`SecurityConfig`, `JwtFilter`, `JwtUtil`).
  - `entities` / `dto` — data model and DTO mapping (Lombok builders/constructors used heavily).

- Authentication/Authorization:
  - JWTs are generated by `JwtUtil.generateToken(User)` and validated in `JwtFilter`.
  - `JwtFilter` places a fully-populated `User` entity into the SecurityContext; controllers access the principal via `@AuthenticationPrincipal com.example.userssdk.entities.User`.
  - Headers: use `Authorization: Bearer <token>`.

- Important security behavior discovered from the code (review before changing):
  - `SecurityConfig` currently permits `/api/auth/**` and explicitly allows `PUT /api/auth/users/**` and `GET /api/auth/my-users`. This means some update endpoints are permissive for ease of testing—treat this as deliberate when altering rules.
  - CORS is configured in `SecurityConfig.corsConfigurer()` — allowed origins include `http://localhost:8080` and `http://18.205.24.184:8080`.

## Data model patterns & conventions

- `User` entity has a self-referential ManyToOne `admin` field (an admin can have many users). Use `UserDTO` to carry `adminId` rather than full admin circular structures.
- Custom fields are modelled as `UserCustomField` with a ManyToOne back to `User` and are converted to/from `CustomFieldDTO` in `UserDTO` and service layer.
- Lombok is used everywhere (`@Data`, `@Builder`, `@RequiredArgsConstructor`) — prefer editing generated constructors/annotations rather than hand-writing boilerplate.

## Concrete examples (use these when generating or testing code)

- Register JSON (see `RegisterRequest` fields):

  {
    "name": "Alice",
    "email": "alice@example.com",
    "password": "secret",
    "role": "USER",        // enum: Role
    "adminId": 1,
    "customFields": [{"fieldName":"team","fieldValue":"qa"}]
  }

- Login JSON (see `LoginRequest`): { "email": "alice@example.com", "password": "secret" }
- Endpoint examples:
  - POST /api/auth/register → returns `AuthResponse` (token + `UserDTO`)
  - POST /api/auth/login → returns `AuthResponse`
  - GET /api/auth/me → uses authenticated `User` principal
  - GET /api/admin/users/{userId}/fields → manage custom fields

## Build / debug tips specific to this repo

- SQL logging is enabled (`spring.jpa.show-sql=true`) — helpful for tracing repository queries.
- To change JWT secret at runtime, set `APP_JWT_SECRET` or override `app.jwt.secret` in `application.properties` or via environment variable when running the container.
- If you need a reproducible DB, use `docker compose up --build` — the compose file creates a Postgres container with DB `usersdb` and user `arielhalevy`.

## Files to reference when making changes

- `src/main/java/com/example/userssdk/config/JwtFilter.java` — how tokens become an authenticated `User` principal
- `src/main/java/com/example/userssdk/config/SecurityConfig.java` — current route permissions and CORS
- `src/main/java/com/example/userssdk/controllers/AuthController.java` — common auth endpoints and principal checks
- `src/main/java/com/example/userssdk/service/UserServiceImpl.java` — registration/login logic and DTO mappings
- `src/main/resources/application.properties` and `docker-compose.yml` — runtime configuration patterns

## Minimal rules for automated edits

- Preserve Lombok annotations and JPA mapping semantics. When changing entity fields, update `UserDTO` and the service mapping logic accordingly.
- When modifying security rules in `SecurityConfig`, keep `JwtFilter` integration (added with `addFilterBefore`) and verify endpoints still work with `Authorization: Bearer <token>`.

If anything above is unclear or you'd like the doc to include more examples (curl commands, sample test setup, or CI instructions), tell me which parts to expand.
